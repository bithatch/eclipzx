/*
 * generated by Xtext 2.39.0
 */
package uk.co.bithatch.zxbasic.scoping;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.impl.ResourceImpl;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import com.google.common.collect.Iterators;
import com.google.common.collect.Lists;
import com.google.inject.Inject;

import uk.co.bithatch.zxbasic.ILanguageSettings;
import uk.co.bithatch.zxbasic.IReferenceIndex;
import uk.co.bithatch.zxbasic.basic.ArgSpec;
import uk.co.bithatch.zxbasic.basic.Assignment;
import uk.co.bithatch.zxbasic.basic.BasicFactory;
import uk.co.bithatch.zxbasic.basic.BasicPackage;
import uk.co.bithatch.zxbasic.basic.DimDeclaration;
import uk.co.bithatch.zxbasic.basic.FunctionBlock;
import uk.co.bithatch.zxbasic.basic.Group;
import uk.co.bithatch.zxbasic.basic.PPDefine;
import uk.co.bithatch.zxbasic.basic.PPIfdef;
import uk.co.bithatch.zxbasic.basic.PPIfndef;
import uk.co.bithatch.zxbasic.basic.PPUndef;
import uk.co.bithatch.zxbasic.basic.Program;
import uk.co.bithatch.zxbasic.basic.SubBlock;

/**
 * This class contains custom scoping description.
 * 
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class BasicScopeProvider extends AbstractBasicScopeProvider {
	@Inject
	private ZXBasicGlobalScopeProvider  globalScopeProvider;

	@Inject
	private IReferenceIndex referenceIndex;

	@Override
	public IScope getScope(EObject context, EReference eRef) {

		if (context instanceof PPUndef || context instanceof PPIfdef  || context instanceof PPIfndef) {
			var program = findProgram(context);
			return Scopes.scopeFor(Lists.newArrayList(Iterators.filter(program.eAllContents(), e -> {
				return e instanceof PPDefine;
			})), n -> QualifiedName.create(((PPDefine)n).getName()), IScope.NULLSCOPE);
		}

		else if (eRef.equals(BasicPackage.Literals.REFERABLE_REF__REF)) {

			var program = findProgram(context);

			var all = new ArrayList<EObject>();
			all.addAll(getAllReferables(program));

	        // Add from included files
	        var resource = program.eResource();
	        var uris = globalScopeProvider.getImportedUris(resource);
	        for (var uri : uris) {
	            var includedRes = resource.getResourceSet().getResource(uri, true);
	            if (includedRes != null && includedRes.isLoaded() && !includedRes.getContents().isEmpty()) {
	                var root = includedRes.getContents().get(0);
	                if (root instanceof Program includedProg) {
	                    all.addAll(getAllReferables(includedProg));
	                }
	            }
	        }

			var allNames = new ArrayList<IEObjectDescription>();
	        
	        // Add arguments if in sub or function
	        var callableArgs = findCallableArgs(context);
	        if(callableArgs != null) {
	        	all.addAll(callableArgs);
	        }

			var exists = new HashSet<String>();

			// TODO dont think this is needed any more
//			if(languageSettings.isNormalizeCase(context, null)) {
//				allNames.addAll(all.stream().map(s -> {
//					if (s instanceof DimDeclaration dim) {
//						return createNormalisedDescription(exists, s, dim.getName());
//					} else if (s instanceof FunctionBlock fnc) {
//						return createNormalisedDescription(exists, s, fnc.getName());
//					} else if (s instanceof Assignment asgn) {
//						return createNormalisedDescription(exists, s, asgn.getName());
//					} else if (s instanceof SubBlock sub) {
//						return createNormalisedDescription(exists, s, sub.getName());
//					} else if (s instanceof ArgSpec aspec) {
//						return createNormalisedDescription(exists, s, aspec.getName());
//					} else {
//						throw new IllegalArgumentException("Unexpected type.");
//					}
//				}).toList());
//			}

			allNames.addAll(all.stream().map(s -> {
				if (s instanceof DimDeclaration dim) {
					return createUnnormalisedDescription(exists, s, dim.getName());
				} else if (s instanceof FunctionBlock fnc) {
					return createUnnormalisedDescription(exists, s, fnc.getName());
				} else if (s instanceof Assignment asgn) {
					return createUnnormalisedDescription(exists, s, asgn.getName());
				} else if (s instanceof SubBlock sub) {
					return createUnnormalisedDescription(exists, s, sub.getName());
				} else if (s instanceof ArgSpec aspec) {
					return createUnnormalisedDescription(exists, s, aspec.getName());
				} else {
					throw new IllegalArgumentException("Unexpected type.");
				}
			}).filter(f -> f != null).toList());

			/* Labels are case sensitive */
			allNames.addAll(getLabels(program).stream().map(l -> {
				var lbl = ScopingUtils.numberOrLabel(l);
				if (!exists.contains(lbl)) {
					QualifiedName name = QualifiedName.create(lbl);
					exists.add(lbl);
					return EObjectDescription.create(name, l);
				} else {
					return null;
				}
			}).filter(l -> l != null).toList());

			var delegate = new SimpleScope(super.getScope(context, eRef), allNames, true);

//		    return addLabels(addBuiltInFunctions(delegate), delegate, context);
			return addBuiltInFunctions(delegate, program);
		}

		return super.getScope(context, eRef);
	}

	protected IEObjectDescription createUnnormalisedDescription(HashSet<String> exists, EObject s, String lname) {
		if (exists.contains(lname)) {
			return null;
		}
		QualifiedName name = QualifiedName.create(lname);
		exists.add(lname);
		return EObjectDescription.create(name, s);
	}

	protected IEObjectDescription createNormalisedDescription(HashSet<String> exists, EObject s, String lname) {
		var normName = lname.toUpperCase();
		exists.add(normName);
		QualifiedName name = QualifiedName.create(normName);
		return EObjectDescription.create(name, s);
	}
	
	private EList<ArgSpec> findCallableArgs(EObject obj) {
		while(obj != null) {
			if(obj instanceof FunctionBlock fblock) {
				return fblock.getArgs();
			}
			else if(obj instanceof SubBlock sblock) {
				return sblock.getArgs();
			}
			obj = obj.eContainer();
		}
		return null;
	}
	

	private ArrayList<EObject> getAllReferables(EObject program) {
		return Lists.newArrayList(Iterators.filter(program.eAllContents(), e -> {
			return e instanceof DimDeclaration || e instanceof FunctionBlock || e instanceof Assignment
					|| e instanceof SubBlock;
		}));
	}

	private List<Group> getLabels(Program program) {
		return program.getProgram().getGroups().stream().filter(line -> line instanceof Group).map(line -> (Group) line)
				.filter(ScopingUtils::hasNumberOrLabel).collect(Collectors.toList());
	}

	private IScope addBuiltInFunctions(IScope parent, EObject context) {
		/* Add functions in our runtime implementation */
		var builtIns = new ArrayList<IEObjectDescription>();

		for (var name : referenceIndex.definitions()) {
			// Create a synthetic EObject and wrap it with a description
//			var fname = ScopingUtils.normalizeIdentifier(name, languageSettings, context);
			var fname = name;
			var fakeFunc = createFunctionStub(fname);
			var desc = EObjectDescription.create(QualifiedName.create(fname), fakeFunc);
			builtIns.add(desc);
		}
		

        
        // Add defines found by preprocessor
        SourceMapRegistry.get(context).ifPresent(sm -> {
        	for(var def : sm.defines().keySet()) {
    			var fakeFunc = createDefStub(def);
    			var desc = EObjectDescription.create(QualifiedName.create(def), fakeFunc);
    			builtIns.add(desc);
        	}
        });

		return new SimpleScope(parent, builtIns, true);
	}

	private EObject createDefStub(String name) {
		var stub = BasicFactory.eINSTANCE.createPPDefine(); // or FunctionDef
		stub.setDefine("#define " + name);
		return stub;
	}

	private EObject createFunctionStub(String name) {
		var stub = BasicFactory.eINSTANCE.createFunctionBlock(); // or FunctionDef
		stub.setName(name);

		Resource dummyResource = new ResourceImpl(URI.createURI("zxb://" + name.toLowerCase()));
		dummyResource.getContents().add(stub);

		return stub;
	}

	private Program findProgram(EObject obj) {
		while (obj != null && !(obj instanceof Program)) {
			obj = obj.eContainer();
		}
		return (Program) obj;
	}
}
